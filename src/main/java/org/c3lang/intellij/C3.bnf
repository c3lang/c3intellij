{
    parserClass = "org.c3lang.intellij.parser.C3Parser"
    extends = "org.c3lang.intellij.psi.impl.C3PsiElementImpl"
    implements = "org.c3lang.intellij.psi.C3PsiElement"

    psiClassPrefix = "C3"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.c3lang.intellij.psi"
    psiImplPackage = "org.c3lang.intellij.psi.impl"
    psiImplUtilClass = "org.c3lang.intellij.psi.impl.C3ParserUtils"
    parserUtilClass = "org.c3lang.intellij.psi.impl.C3ParserUtil"

    elementTypeHolderClass = "org.c3lang.intellij.psi.C3Types"
    elementTypeClass = "org.c3lang.intellij.psi.C3ElementType"
    tokenTypeClass = "org.c3lang.intellij.psi.C3TokenType"

    extends(".*_expr") = expr
    elementType(".*_bin_expr") = binary_expr
    elementType(".*_bin_op") = binary_op

    mixin("func_def") = "org.c3lang.intellij.psi.impl.C3FuncDefMixinImpl"
    implements("func_def") = "org.c3lang.intellij.psi.C3FuncDefMixin"

    mixin("macro_definition") = "org.c3lang.intellij.psi.impl.C3MacroDefinitionMixinImpl"
    implements("macro_definition") = "org.c3lang.intellij.psi.C3MacroDefinitionMixin"

    mixin("module") = "org.c3lang.intellij.psi.impl.C3ModuleMixinImpl"
    implements("module") = "org.c3lang.intellij.psi.C3ModuleMixin"

    mixin("type_name") = "org.c3lang.intellij.psi.impl.C3TypeNameMixinImpl"
    implements("type_name") = "org.c3lang.intellij.psi.C3TypeNameMixin"

    mixin("const_declaration_stmt") = "org.c3lang.intellij.psi.impl.C3ConstDeclarationStmtMixinImpl"
    implements("const_declaration_stmt") = "org.c3lang.intellij.psi.C3ConstDeclarationStmtMixin"

    mixin("call_expr") = "org.c3lang.intellij.psi.impl.C3CallExprMixinImpl"
    implements("call_expr") = "org.c3lang.intellij.psi.C3CallExprMixin"

    mixin("path") = "org.c3lang.intellij.psi.impl.C3PathMixinImpl"
    implements("path") = "org.c3lang.intellij.psi.C3PathMixin"

    mixin("path_ident") = "org.c3lang.intellij.psi.impl.C3PathIdentMixinImpl"
    implements("path_ident") = "org.c3lang.intellij.psi.C3PathIdentMixin"
    methods("path_ident") = [ getPath ]

    mixin("path_ident_expr") = "org.c3lang.intellij.psi.impl.C3PathIdentExprMixinImpl"
    implements("path_ident_expr") = "org.c3lang.intellij.psi.C3PathIdentExprMixin"

    mixin("path_const") = "org.c3lang.intellij.psi.impl.C3PathConstMixinImpl"
    implements("path_const") = "org.c3lang.intellij.psi.C3PathConstMixin"

    mixin("import_path") = "org.c3lang.intellij.psi.impl.C3ImportPathMixinImpl"
    implements("import_path") = "org.c3lang.intellij.psi.C3ImportPathMixin"

    mixin("arg") = "org.c3lang.intellij.psi.impl.C3ArgMixinImpl"
    implements("arg") = "org.c3lang.intellij.psi.C3ArgMixin"

    mixin("parameter") = "org.c3lang.intellij.psi.impl.C3ParameterMixinImpl"
    implements("parameter") = "org.c3lang.intellij.psi.C3ParameterMixin"

    mixin("func_name") = "org.c3lang.intellij.psi.impl.C3FuncNameMixinImpl"
    implements("func_name") = "org.c3lang.intellij.psi.C3FuncNameMixin"

    mixin("default_module_section|module_section") = "org.c3lang.intellij.psi.impl.C3ModuleDefinitionMixinImpl"
    implements("default_module_section|module_section") = "org.c3lang.intellij.psi.C3ModuleDefinition"

    mixin("parameter_list") = "org.c3lang.intellij.psi.impl.C3ParameterListMixinImpl"
    implements("parameter_list") = "org.c3lang.intellij.psi.C3ParameterListMixin"

    mixin("local_decl_after_type") = "org.c3lang.intellij.psi.impl.C3LocalDeclAfterTypeMixinImpl"
    implements("local_decl_after_type") = "org.c3lang.intellij.psi.C3LocalDeclAfterTypeMixin"

    mixin("local_declaration_stmt") = "org.c3lang.intellij.psi.impl.C3LocalDeclarationStmtMixinImpl"
    implements("local_declaration_stmt") = "org.c3lang.intellij.psi.C3LocalDeclarationStmtMixin"

    mixin("base_type") = "org.c3lang.intellij.psi.impl.C3BaseTypeMixinImpl"
    implements("base_type") = "org.c3lang.intellij.psi.C3BaseTypeMixin"

    mixin("access_ident") = "org.c3lang.intellij.psi.impl.C3AccessIdentMixinImpl"
    implements("access_ident") = "org.c3lang.intellij.psi.C3AccessIdentMixin"

    mixin("struct_declaration") = "org.c3lang.intellij.psi.impl.C3StructDeclarationMixinImpl"
    implements("struct_declaration") = "org.c3lang.intellij.psi.C3StructDeclarationMixin"

    mixin("struct_member_declaration") = "org.c3lang.intellij.psi.impl.C3StructMemberDeclarationMixinImpl"
    implements("struct_member_declaration") = "org.c3lang.intellij.psi.C3StructMemberDeclarationMixin"

    mixin("enum_constant") = "org.c3lang.intellij.psi.impl.C3EnumConstantMixinImpl"
    implements("enum_constant") = "org.c3lang.intellij.psi.C3EnumConstantMixin"

    mixin("param_path_element") = "org.c3lang.intellij.psi.impl.C3ParamPathElementMixinImpl"
    implements("param_path_element") = "org.c3lang.intellij.psi.C3ParamPathElementMixin"

    methods("path") = [ getImportIntention ]

    // for exception: java.lang.ClassCastException: Not a stub type: C3TokenType.CONST_DECLARATION_STMT in class org.c3lang.intellij.psi.impl.C3ConstDeclarationStmtImpl
    // add all C3StubBasedPsiElementBase mixins
    elementTypeFactory("func_def|macro_definition|module|type_name|const_declaration_stmt|struct_member_declaration|struct_declaration|enum_constant") = "org.c3lang.intellij.psi.C3StubElementTypeFactory.stubFactory"

    pin(".*_decl") = 2
    pin(".*_declaration") = 2
    pin(".*_stmt") = 1

    /*tokens = [
            KW_ANY = "any"
            KW_ANYFAULT = "anyfault"
            KW_ASM = "asm"
            KW_ASSERT = "assert"
            KW_BITSTRUCT = "bitstruct"
            KW_BREAK = "break"
            KW_CASE = "case"
            KW_CATCH = "catch"
            KW_CONST = "const"
            KW_CONTINUE = "continue"
            KW_DEF = "def"
            KW_DEFAULT = "default"
            KW_DEFER = "defer"
            KW_DISTINCT = "distinct"
            KW_DO = "do"
            KW_ELSE = "else"
            KW_ENUM = "enum"
            KW_EXTERN = "extern"
            KW_FOREACH = "foreach"
            KW_FOREACH_R = "foreach_r"
            KW_FALSE = "false"
            KW_FAULT = "fault"
            KW_FOR = "for"
            KW_FN = "fn"
            KW_IF = "if"
            KW_INLINE = "inline"
            KW_INTERFACE = "interface"
            KW_IMPORT = "import"
            KW_MACRO = "macro"
            KW_MODULE = "module"
            KW_NEXTCASE = "nextcase"
            KW_NULL = "null"
            KW_RETURN = "return"
            KW_STATIC = "static"
            KW_STRUCT = "struct"
            KW_SWITCH = "switch"
            KW_TLOCAL = "tlocal"
            KW_TRUE = "true"
            KW_TRY = "try"
            KW_TYPEID = "typeid"
            KW_UNION = "union"
            KW_VAR = "var"
            KW_WHILE = "while"
            KW_CT_ALIGNOF = "$alignof"
            KW_CT_ASSERT = "$assert"
            KW_CT_CASE = "$case"
            KW_CT_DEFAULT = "$default"
            KW_CT_DEFINED = "$defined"
            KW_CT_ECHO = "$echo"
            KW_CT_ELSE = "$else"
            KW_CT_ENDFOR = "$endfor"
            KW_CT_ENDFOREACH = "$endforeach"
            KW_CT_ENDIF = "$endif"
            KW_CT_ENDSWITCH = "$endswitch"
            KW_CT_ERROR = "$error"
            KW_CT_EVAL = "$eval"
            KW_CT_EVALTYPE = "$evaltype"
            KW_CT_EXTNAMEOF = "$extnameof"
            KW_CT_FEATURE = "$feature"
            KW_CT_FOR = "$for"
            KW_CT_FOREACH = "$foreach"
            KW_CT_IF = "$if"
            KW_CT_IS_CONST = "$is_const"
            KW_CT_INCLUDE = "$include"
            KW_CT_NAMEOF = "$nameof"
            KW_CT_SIZEOF = "$sizeof"
            KW_CT_STRINGIFY = "$stringify"
            KW_CT_SWITCH = "$switch"
            KW_CT_TYPEOF = "$typeof"
            KW_CT_TYPEFROM = "$typefrom"
            KW_CT_QNAMEOF = "$qnameof"
            KW_CT_VACOUNT = "$vacount"
            KW_CT_VACONST = "$vaconst"
            KW_CT_VATYPE = "$vatype"
            KW_CT_VAARG = "$vaarg"
            KW_CT_VAREF = "$varef"
            KW_CT_VAEXPR = "$vaexpr"
            KW_CT_VASPLAT = "$vasplat"
            KW_VOID = "void"
            KW_BOOL = "bool"
            KW_CHAR = "char"
            KW_ICHAR = "ichar"
            KW_SHORT = "short"
            KW_USHORT = "ushort"
            KW_INT = "int"
            KW_UINT = "uint"
            KW_LONG = "long"
            KW_ULONG = "ulong"
            KW_UINT128 = "uint128"
            KW_INT128 = "int128"
            KW_BFLOAT16 = "bfloat16"
            KW_DOUBLE = "double"
            KW_FLOAT = "float"
            KW_FLOAT16 = "float16"
            KW_FLOAT128 = "float128"
            KW_UPTR = "uptr"
            KW_IPTR = "iptr"
            KW_USZ = "usz"
            KW_ISZ = "isz"
            CT_AND="&&&"
            CT_OR="|||"
            CT_PLUS="+++"
            ELLIPSIS="..."
            SHL_ASSIGN="<<="
            SHR_ASSIGN=">>="
            AND="&&"
            BAD_CHARACTER="->"
            BIT_AND_ASSIGN="&="
            BIT_OR_ASSIGN="|="
            BIT_XOR_ASSIGN="^="
            DIV_ASSIGN="/="
            DOTDOT=".."
            ELVIS="?:"
            EQ_OP="=="
            GE_OP=">="
            IMPLIES="=>"
            LE_OP="<="
            LBRAPIPE="{|"
            LVEC="[<"
            LGENPAR="(<"
            MINUS_ASSIGN="-="
            MINUSMINUS="--"
            MOD_ASSIGN="%="
            MULT_ASSIGN="*="
            NE_OP="!="
            OR="||"
            PLUS_ASSIGN="+="
            PLUSPLUS="++"
            RBRAPIPE="|}"
            RVEC=">]"
            RGENPAR=">)"
            SCOPE="::"
            SHR=">>"
            SHL="<<"
            BANGBANG="!!"
            OPTELSE="??"
            AMP="&"
            BAD_CHARACTER="@"
            BANG="!"
            BIT_NOT="~"
            BIT_OR="|"
            BIT_XOR="^"
            COLON=":"
            COMMA=","
            EOS=";"
            EQ="="
            GT_OP=">"
            DIV="/"
            UNDERSCORE="_"
            BAD_CHARACTER="$"
            DOT="."
            BAD_CHARACTER="#"
            LT_OP="<"
            LB="{"
            LBT="["
            LP="("
            MINUS="-"
            MOD="%"
            PLUS="+"
            QUESTION="?"
            RBT="]"
            RB="}"
            RP=")"
            STAR="*"

            CONST_IDENT = "regexp:_*[A-Z][A-Z_0-9]"
            AT_CONST_IDENT = "regexp:@_*[A-Z][A-Z_0-9]"
            HASH_CONST_IDENT = "regexp:#_*[A-Z][A-Z_0-9]"
            CT_CONST_IDENT = "regexp:\$_*[A-Z][A-Z_0-9]"
            AT_TYPE_IDENT = "regexp:@_*[A-Z][A-Z_0-9]*[a-z][a-zA-Z_0-9]*"
            HASH_TYPE_IDENT = "regexp:#_*[A-Z][A-Z_0-9]*[a-z][a-zA-Z_0-9]*"
            CT_TYPE_IDENT = "regexp:\$_*[A-Z][A-Z_0-9]*[a-z][a-zA-Z_0-9]*"
            TYPE_IDENT = "regexp:_*[A-Z][A-Z_0-9]*[a-z][a-zA-Z_0-9]*"
            BUILTIN_CONST = "regexp:\$\$_*[A-Z][A-Z_0-9]"
            BUILTIN = "regexp:\$\$_*[a-z][a-zA-Z_0-9]*"
            AT_IDENT = "regexp:@_*[a-z][a-zA-Z_0-9]*"
            HASH_IDENT = "regexp:#_*[a-z][a-zA-Z_0-9]*"

            IDENT = "regexp:_*[a-z][a-zA-Z_0-9]*"
            CT_IDENT = "regexp:\$_*[a-z][a-zA-Z_0-9]*"
            E = "regexp:[Ee][+-]?[0-9]+}"
            P = "regexp:[Pp][+-]?[0-9]+"
            SIZES = "regexp:(8|16|32|64|128)"
            INTTYPE = "regexp:([lL]|[uU][lL]|[uU](8|16|32|64|128)?|[iI](8|16|32|64|128))"
            REALTYPE = "regexp:[fF](8|16|32|64|128)?"

            INT_LITERAL = "regexp:[0-9]*"
            FLOAT_LITERAL = "regexp:(_*[0-9])*"
            STRING_LIT = "regexp:[\"']\w*([\"'])"

            INT = "regexp:[0-9](_*[0-9])*"
            HINT = "regexp:[a-fA-F0-9](_*[a-fA-F0-9])*"
            OINT = "regexp:[0-7](_*[0-7])*"
            BINT = "regexp:[0-1](_*[0-1])*"


            EOL = "\n"

            HEX_LIT = "regexp:0[xX][a-fA-F0-9](_*[a-fA-F0-9])*" //"0" [xX] {HINT}
            OCTAL_LIT = "regexp:0[oO][0-7](_*[0-7])*" //"0" [oO] {OINT}
            BINARY_LIT = "regexp:0[bB][0-1](_*[0-1])*" //"0" [bB] {BINT}
            DECIMAL_LIT = "regexp:[0-9](_*[0-9])*" //{INT}

            WHITESPACE ="regexp:\s+|\n+"
        ]*/
}

translation_unit ::= default_module_section? module_section*
default_module_section ::= top_level+
module_section ::= module top_level*

module_path::= [(IDENT SCOPE)+] IDENT
//module_path::= [(IDENT SCOPE)+] IDENT
module ::= KW_MODULE module_path (LGENPAR module_params RGENPAR)? attributes? EOS { pin=2 }

type_decl ::= struct_declaration
    | fault_declaration
    | enum_declaration
    | bitstruct_declaration

fake binary_expr ::= expr+ {
    methods = [left = "expr[0]" right = "expr[1]"]
}

fake binary_op ::= add_bin_op | mult_bin_op | bit_bin_op | shift_bin_op | rel_bin_op | assign_bin_op

//path ::=  <<parsePath>>
path ::= (IDENT SCOPE)+ { pin(".*")=2 }
path_const ::= path? CONST_IDENT { pin=2 }
path_ident ::= <<parsePathIdent>>
//path_ident ::= path? IDENT { pin=2 }

path_at_ident ::= path? AT_IDENT  { pin = 2}

module_param ::= TYPE_IDENT | CONST_IDENT

module_params ::= module_param (COMMA module_param)*

import_decl ::= KW_IMPORT import_paths attributes? EOS
import_path ::= IDENT (SCOPE IDENT)*  { pin(".*") = 1 }
import_paths ::= import_path (COMMA import_path)*

ct_include_stmt ::= KW_CT_INCLUDE string_expr attributes? EOS

asm_declaration ::= KW_ASM expr attributes? EOS

top_level ::= import_decl
    | KW_EXTERN? (func_definition | const_declaration_stmt | global_decl)
    | ct_assert_stmt
    | ct_error_stmt
    | ct_echo_stmt
    | ct_include_stmt
    | type_decl
    | def_decl
    | fault_declaration
    | macro_definition
    | asm_declaration
    | interface_definition
    | distinct_declaration

private const_paren_expr ::= LP constant_expr RP

attributes ::= attribute+
attribute ::= attribute_name (LP attribute_param_list RP)?
attribute_name ::= AT_IDENT | path? AT_TYPE_IDENT
attribute_param_list ::= attr_param (COMMA attr_param)*
attr_param ::= attribute_operator_expr | constant_expr
attribute_operator_expr ::= LBT RBT EQ | AMP? LBT RBT
private struct_or_union ::= KW_STRUCT | KW_UNION

type_name ::= TYPE_IDENT

struct_declaration ::= struct_or_union type_name interface_impl? attributes? struct_body

bitstruct_declaration ::= KW_BITSTRUCT type_name interface_impl? COLON type attributes? bitstruct_body

func_typedef ::= KW_FN optional_type fn_parameter_list


typedef_type ::= func_typedef | type generic_parameters?
generic_parameter ::= expr | type
generic_parameters ::= LGENPAR generic_parameter (COMMA generic_parameter)* RGENPAR
any_ident ::= AT_TYPE_IDENT | TYPE_IDENT | CT_TYPE_IDENT | AT_IDENT | IDENT | CONST_IDENT | CT_CONST_IDENT

def_attr_values ::= LB attributes? RB
def_declaration_source ::= (def_attr_values | path_const | path_ident | typedef_type | any_ident) generic_parameters?
def_decl ::= KW_DEF any_ident (LP parameter_list RP)? EQ def_declaration_source attributes? EOS

struct_body ::= LB struct_member_declaration* RB { pin(".*")=2 }

private struct_member_declaration_1 ::= type identifier_list attributes? EOS { pin(".*")=1 }
private struct_member_declaration_2 ::= KW_INLINE type IDENT? attributes? EOS { pin(".*")=2 }
private struct_member_declaration_3 ::= struct_or_union IDENT? attributes? struct_body { pin(".*")=1}
private struct_member_declaration_4 ::= KW_BITSTRUCT IDENT? ':' type attributes? bitstruct_body {pin(".*")=4}

struct_member_declaration ::= struct_member_declaration_1
                              | struct_member_declaration_2
                              | struct_member_declaration_3
                              | struct_member_declaration_4

bitstruct_body ::= LB (bitstruct_def+ | bitstruct_simple_def+)? RB
bitstruct_def ::= base_type IDENT COLON constant_expr (DOTDOT constant_expr)? EOS
bitstruct_simple_def ::= base_type IDENT EOS

enum_declaration ::= KW_ENUM type_name interface_impl? (COLON enum_spec)? attributes? LB enum_list RB
enum_spec ::= enum_param_list | type enum_param_list?
enum_param_list ::=  LP enum_param_decl (COMMA enum_param_decl)* RP
enum_param_decl ::= type IDENT
enum_list ::= enum_constant (COMMA enum_constant ?)* COMMA?
enum_constant ::= CONST_IDENT attributes? [eq_expr_pin]
arg_list ::= arg (COMMA arg)* COMMA?
named_ident ::= CT_IDENT | HASH_IDENT | IDENT | CT_TYPE_IDENT
arg ::= (named_ident COLON (expr | type)) | param_path (EQ (expr | type))? | expr | type | KW_CT_VASPLAT (LBT range_exp RBT)? | ELLIPSIS expr


global_decl ::= KW_TLOCAL? optional_type IDENT (global_multi_declaration | global_single_declaration) EOS
global_multi_declaration ::= multi_declaration attributes?
global_single_declaration ::= attributes? [eq_expr_pin]
multi_declaration ::= (COMMA IDENT)+

grouped_expression ::= LP expr RP

access_ident ::= IDENT | AT_IDENT | HASH_IDENT | KW_CT_EVAL '(' expr ')' | KW_TYPEID

call_arg_list ::= arg_list? (EOS parameter_list?)?
call_invocation ::= LP call_arg_list RP AT_IDENT*
private dot_access_ident ::= DOT access_ident { pin=1 }
call_expr_tail ::= call_invocation compound_statement?
    | LBT (range_exp | range_loc) RBT
    | generic_parameters
    | dot_access_ident
    | PLUSPLUS
    | MINUSMINUS
    | BANG
    | BANGBANG


ct_call ::= KW_CT_ALIGNOF | KW_CT_EXTNAMEOF | KW_CT_NAMEOF | KW_CT_OFFSETOF | KW_CT_QNAMEOF
ct_arg ::= KW_CT_VACONST | KW_CT_VAARG | KW_CT_VAREF | KW_CT_VAEXPR
ct_analyze ::= KW_CT_EVAL | KW_CT_SIZEOF | KW_CT_STRINGIFY | KW_CT_IS_CONST

flat_path ::= primary_group param_path? | type
param_path ::= param_path_element+
param_path_element ::= LBT expr (DOTDOT expr)? RBT | DOT primary_group | DOT CT_TYPE_IDENT { pin(".*")=1 }

range_exp ::= range_loc? (DOTDOT | COLON) range_loc?
range_loc ::= BIT_XOR? expr
lambda_decl ::= KW_FN optional_type? fn_parameter_list attributes?
optional_type ::= type BANG?
fn_parameter_list ::= LP parameter_list? RP
param_decl ::= parameter [eq_expr_pin]
parameter_list ::= param_decl (COMMA param_decl)*  { pin(".*")=1 }
parameter ::= KW_INLINE? type (ELLIPSIS? IDENT attributes? | ELLIPSIS? CT_IDENT | (HASH_IDENT | AMP IDENT) attributes? | attributes?)
    | ELLIPSIS | AMP IDENT attributes? | HASH_IDENT attributes? | IDENT ELLIPSIS? attributes?
    | CT_IDENT | CT_IDENT ELLIPSIS

ct_error_stmt ::= KW_CT_ERROR constant_expr EOS
ct_assert_stmt ::= KW_CT_ASSERT constant_expr (COLON constant_expr)? EOS
ct_echo_stmt ::= KW_CT_ECHO constant_expr EOS EOS
assert_stmt ::= KW_ASSERT LP expr (COMMA expr)* RP EOS
ct_if_stmt ::= KW_CT_IF constant_expr COLON statement_list? (KW_CT_ELSE statement_list?)? KW_CT_ENDIF

ct_switch_stmt ::= ct_switch ct_switch_body KW_CT_ENDSWITCH
initializer_list ::= LB (arg_list COMMA?)? RB { pin=2 }

integer_type ::= KW_CHAR | KW_ICHAR | KW_SHORT | KW_USHORT | KW_INT | KW_UINT | KW_LONG | KW_ULONG | KW_INT128 | KW_UINT128

float_type ::= KW_FLOAT16 | KW_FLOAT | KW_DOUBLE | KW_FLOAT128 | KW_BFLOAT16

private struct_type ::= path? TYPE_IDENT generic_parameters? { pin=2 }

base_type ::= KW_VOID
    | KW_BOOL
    | integer_type
    | float_type
    | KW_IPTR
    | KW_UPTR
    | KW_ISZ
    | KW_USZ
    | KW_ANYFAULT
    | KW_ANY
    | KW_TYPEID
    | struct_type
    | CT_TYPE_IDENT
    | KW_CT_TYPEOF grouped_expression
    | KW_CT_TYPEFROM const_paren_expr
    | KW_CT_VATYPE LBT expr RBT
    | KW_CT_EVALTYPE const_paren_expr


type_suffix ::= STAR | LBT PLUS RBT | LBT (STAR | QUESTION | DIV | UNDERSCORE | constant_expr)? RBT | LVEC (STAR | constant_expr) RVEC

type ::= base_type type_suffix*

ct_switch ::= KW_CT_SWITCH (LP (constant_expr | type) RP)?

ct_case_stmt ::= (KW_CT_CASE (constant_expr | type) | KW_CT_DEFAULT) COLON statement_list?
ct_switch_body ::= ct_case_stmt+
ct_foreach_stmt ::= KW_CT_FOREACH LP CT_IDENT (COMMA CT_IDENT)? COLON expr RP statement_list? KW_CT_ENDFOREACH
ct_for_stmt ::= KW_CT_FOR LP for_cond RP statement_list? KW_CT_ENDFOR

private eq_expr_pin ::= EQ expr { pin=1 }
private eq_type_pin ::= EQ type { pin=1 }
var_decl ::= KW_VAR (IDENT eq_expr_pin | CT_TYPE_IDENT eq_type_pin? | CT_IDENT eq_expr_pin?)
var_stmt ::= var_decl EOS
expr_stmt ::= expr EOS {pin=1}

statement ::= compound_statement
    | var_stmt
    | const_declaration_stmt
    | local_declaration_stmt
    | return_stmt
    | if_stmt
    | while_stmt
    | defer_stmt
    | switch_stmt
    | do_stmt
    | for_stmt
    | foreach_stmt
    | continue_stmt
    | break_stmt
    | nextcase_stmt
    | asm_block_stmt
    | ct_echo_stmt
    | ct_assert_stmt
    | ct_error_stmt
    | ct_if_stmt
    | ct_switch_stmt
    | ct_foreach_stmt
    | ct_for_stmt
    | expr_stmt
    | assert_stmt
    | EOS { recoverWhile=recover_statement }
private recover_statement ::= !(statement|keyword_list|ident_list|RB|EOS)

local_decl_storage ::= KW_STATIC | KW_TLOCAL

private local_decl_after_type_1 ::= CT_IDENT (EQ constant_expr)?
private local_decl_after_type_2 ::= IDENT attributes? (eq_expr_pin)?
local_decl_after_type ::= local_decl_after_type_1 | local_decl_after_type_2

decl_stmt_after_type ::= local_decl_after_type (COMMA local_decl_after_type)* {pin=1}

const_declaration_stmt ::= KW_CONST type? CONST_IDENT attributes? eq_expr_pin EOS { pin=3 }
local_declaration_stmt ::= local_decl_storage? optional_type decl_stmt_after_type EOS { pin=2 }

return_stmt ::= KW_RETURN expr? EOS
label ::= CONST_IDENT COLON
paren_cond ::= LP cond RP { pin(".*")=2 }
if_stmt ::= KW_IF label? paren_cond (LB switch_body RB else_part? | compound_statement else_part | statement)


while_stmt ::= KW_WHILE label? paren_cond statement
do_stmt ::= KW_DO label? compound_statement (KW_WHILE grouped_expression)? EOS
else_part ::= KW_ELSE (if_stmt | compound_statement)
switch_body ::= (case_stmt | default_stmt)+
case_stmt ::= KW_CASE (expr (DOTDOT expr)? | type) COLON statement_list?
default_stmt ::= KW_DEFAULT COLON statement_list?
switch_stmt ::= KW_SWITCH label? paren_cond? AT_IDENT? LB switch_body? RB
expression_list ::= decl_or_expr (COMMA decl_or_expr)*

cond ::= cond_repeat (COMMA (try_unwrap_chain | catch_unwrap))? | try_unwrap_chain | catch_unwrap
cond_repeat ::= decl_or_expr (COMMA decl_or_expr)*
decl_or_expr ::= var_decl | optional_type local_decl_after_type | expr
for_cond ::= expression_list? EOS cond? EOS expression_list?
for_stmt ::= KW_FOR label? LP for_cond RP statement
foreach_stmt ::= (KW_FOREACH | KW_FOREACH_R) label? LP foreach_vars COLON expr RP statement
foreach_vars ::= foreach_var (COMMA foreach_var)?
foreach_var ::= optional_type? AMP? IDENT
continue_stmt ::= KW_CONTINUE CONST_IDENT? EOS
break_stmt ::= KW_BREAK CONST_IDENT? EOS
nextcase_stmt ::= KW_NEXTCASE ((CONST_IDENT COLON)? (type | expr | KW_DEFAULT))? EOS

asm_block_stmt ::= KW_ASM (LP expr RP attributes? | attributes? LB asm_stmt* RB)
asm_stmt ::= asm_instr asm_exprs? EOS
asm_instr ::= (KW_INT | IDENT) (DOT IDENT)?
asm_exprs ::= asm_expr (COMMA asm_expr)*
asm_expr ::= CT_IDENT | CT_CONST_IDENT | AMP? IDENT | CONST_IDENT
    | MINUS? FLOAT_LITERAL | MINUS? INT_LITERAL | grouped_expression | LBT asm_addr RBT
asm_addr ::= asm_expr (add_bin_op asm_expr asm_addr_trailing?)?
asm_addr_trailing ::= STAR INT_LITERAL (add_bin_op INT_LITERAL)? | (shift_bin_op | add_bin_op) INT_LITERAL

defer_stmt ::= KW_DEFER (KW_TRY | KW_CATCH | (LP KW_CATCH IDENT RP))? statement

compound_statement ::= LB statement_list* RB { pin(".*")=2 }

statement_list ::= statement+

unary_op ::= AMP | AND | STAR | PLUS | MINUS | BIT_NOT | BANG | PLUSPLUS | MINUSMINUS | LP type RP { name = "operator" }
mult_bin_op ::= STAR | DIV | MOD { name = "operator" }
shift_bin_op ::= SHL | SHR { name = "operator "}
bit_bin_op ::= AMP | BIT_XOR | BIT_OR { name = "operator" }
add_bin_op ::= PLUS | MINUS | CT_PLUS { name = "operator" }
rel_bin_op ::= LT_OP !LBT | GT_OP | LE_OP | GE_OP | EQ_OP | NE_OP { name = "operator" }

catch_unwrap_list ::= expr (COMMA expr)*
catch_unwrap ::= KW_CATCH (type? IDENT EQ)? catch_unwrap_list
try_unwrap ::= KW_TRY (type? IDENT EQ)? expr
try_unwrap_chain ::= try_unwrap (AND (try_unwrap | expr))*
implies_body ::= IMPLIES expr

constant_expr ::= expr

assign_bin_op ::= EQ
    | MULT_ASSIGN
    | MOD_ASSIGN
    | DIV_ASSIGN
    | PLUS_ASSIGN
    | MINUS_ASSIGN
    | SHR_ASSIGN
    | SHL_ASSIGN
    | BIT_AND_ASSIGN
    | BIT_XOR_ASSIGN
    | BIT_OR_ASSIGN { name = "operator" }

assign_type_expr ::= CT_TYPE_IDENT /*EQ type*/eq_type_pin
assign_bin_expr ::= expr assign_bin_op expr { rightAssociative=true }
rel_bin_expr ::= expr rel_bin_op expr
add_bin_expr ::= expr add_bin_op expr
bit_bin_expr ::= expr bit_bin_op expr
shift_bin_expr ::= expr shift_bin_op expr
mult_bin_expr ::= expr mult_bin_op expr
and_bin_expr ::= expr (AND | CT_AND) expr
or_bin_expr ::= expr (OR | CT_OR) expr

literal_expr ::= INT_LITERAL | FLOAT_LITERAL
keyword_expr ::= KW_NULL | KW_TRUE | KW_FALSE | KW_CT_VACOUNT
builtin_const_expr ::= BUILTIN_CONST
builtin_expr ::= BUILTIN
path_ident_expr ::= path_ident
path_const_expr ::= path_const
path_at_ident_expr ::= path_at_ident
string_expr ::= STRING_LIT+ | CHAR_LIT
bytes_expr ::= BYTES+
compound_init_expr ::= type initializer_list
grouped_expr ::= LP expr RP
local_ident_expr ::= CT_IDENT | HASH_IDENT
type_access_expr ::= type DOT (access_ident | CONST_IDENT)
expr_block_expr ::= LBRAPIPE statement_list? RBRAPIPE
ct_call_expr ::= ct_call LP flat_path RP
ct_feature_expr ::= KW_CT_FEATURE LP CONST_IDENT RP
ct_arg_expr ::= ct_arg LBT expr RBT
ct_analyze_expr ::= ct_analyze grouped_expression
ct_defined_check_expr ::= expr | type
ct_defined_check_expr_list ::= ct_defined_check_expr (COMMA ct_defined_check_expr)*
ct_defined_expr ::= KW_CT_DEFINED LP ct_defined_check_expr_list RP
lambda_decl_expr ::= lambda_decl compound_statement
lambda_decl_short_expr ::= lambda_decl IMPLIES expr
call_expr ::= expr call_expr_tail
unary_expr ::= unary_op expr { rightAssociative=true }
expr_terminator ::= EOS | RP | RBT | RB | COMMA | COLON
ternary_expr ::= expr QUESTION !((BANGBANG | BANG)? expr_terminator) expr COLON expr { rightAssociative=true }
optional_expr ::= expr QUESTION &((BANGBANG | BANG)? expr_terminator)
elvis_bin_expr ::= expr ELVIS expr { rightAssociative=true }
optelse_bin_expr ::= expr OPTELSE expr { rightAssociative=true }
private ternary_group ::= elvis_bin_expr | optelse_bin_expr | ternary_expr | optional_expr
init_list_expr ::= initializer_list

private primary_group ::= literal_expr
    | path_ident_expr
    | string_expr
    | bytes_expr
    | keyword_expr
    | builtin_const_expr
    | builtin_expr
    | path_const_expr
    | path_at_ident_expr
    | compound_init_expr
    | grouped_expr
    | local_ident_expr
    | type_access_expr
    | expr_block_expr
    | ct_call_expr
    | ct_feature_expr
    | ct_arg_expr
    | ct_analyze_expr
    | ct_defined_expr
    | lambda_decl_expr
    | lambda_decl_short_expr
    | init_list_expr

expr ::= ternary_group
    | assign_bin_expr
    | assign_type_expr
    | or_bin_expr
    | and_bin_expr
    | rel_bin_expr
    | add_bin_expr
    | bit_bin_expr
    | shift_bin_expr
    | mult_bin_expr
    | unary_expr
    | call_expr
    | primary_group

identifier_list ::= IDENT (COMMA IDENT)*

interface_definition ::= KW_INTERFACE type_name (COLON type (COMMA type)*)? interface_body

interface_body ::= LB (func_def EOS)* RB

func_def ::= KW_FN func_header fn_parameter_list attributes?
func_definition ::= func_def (macro_func_body | EOS) { pin=1 }

macro_func_body ::= implies_body EOS | compound_statement

interface_impl ::= LP type_name (COMMA type)* RP

distinct_declaration ::= KW_DISTINCT type_name interface_impl? attributes? '=' KW_INLINE? type generic_parameters? EOS

func_name ::= (type DOT)? IDENT

func_header ::= optional_type func_name  { pin=2 }

fault_declaration ::= KW_FAULT type_name interface_impl? attributes? LB CONST_IDENT (COMMA CONST_IDENT)* COMMA? RB

macro_name ::= (type DOT)? (AT_IDENT | IDENT)
macro_definition ::= KW_MACRO macro_header LP macro_params RP attributes? macro_func_body
macro_header ::= (optional_type !DOT)? macro_name { pin=2 }

macro_params ::= parameter_list? (EOS trailing_block_param)?
trailing_block_param ::= AT_IDENT (LP parameter_list? RP)?

private keyword_list ::= KW_ANY | KW_ANYFAULT | KW_ASM | KW_ASSERT | KW_BITSTRUCT | KW_BREAK | KW_CASE | KW_CATCH | KW_CONST | KW_CONTINUE | KW_DEF | KW_DEFAULT | KW_DEFER | KW_DISTINCT | KW_DO | KW_ELSE | KW_ENUM | KW_EXTERN | KW_FOREACH | KW_FOREACH_R | KW_FALSE | KW_FAULT | KW_FOR | KW_FN | KW_IF | KW_INLINE | KW_INTERFACE | KW_IMPORT | KW_MACRO | KW_MODULE | KW_NEXTCASE | KW_NULL | KW_RETURN | KW_STATIC | KW_STRUCT | KW_SWITCH | KW_TLOCAL | KW_TRUE | KW_TRY | KW_TYPEID | KW_UNION | KW_VAR | KW_WHILE | KW_CT_ALIGNOF | KW_CT_ASSERT | KW_CT_CASE | KW_CT_DEFAULT | KW_CT_DEFINED | KW_CT_ECHO | KW_CT_ELSE | KW_CT_ENDFOR | KW_CT_ENDFOREACH | KW_CT_ENDIF | KW_CT_ENDSWITCH | KW_CT_ERROR | KW_CT_EVAL | KW_CT_EVALTYPE | KW_CT_EXTNAMEOF | KW_CT_FEATURE | KW_CT_FOR | KW_CT_FOREACH | KW_CT_IF | KW_CT_IS_CONST | KW_CT_INCLUDE | KW_CT_NAMEOF | KW_CT_SIZEOF | KW_CT_STRINGIFY | KW_CT_SWITCH | KW_CT_TYPEOF | KW_CT_TYPEFROM | KW_CT_QNAMEOF | KW_CT_VACOUNT | KW_CT_VACONST | KW_CT_VATYPE | KW_CT_VAARG | KW_CT_VAREF | KW_CT_VAEXPR | KW_CT_VASPLAT | KW_VOID | KW_BOOL | KW_CHAR | KW_ICHAR | KW_SHORT | KW_USHORT | KW_INT | KW_UINT | KW_LONG | KW_ULONG | KW_UINT128 | KW_INT128 | KW_BFLOAT16 | KW_DOUBLE | KW_FLOAT | KW_FLOAT16 | KW_FLOAT128 | KW_UPTR | KW_IPTR | KW_USZ | KW_ISZ
private ident_list ::= IDENT | TYPE_IDENT | CT_TYPE_IDENT | CT_IDENT | CONST_IDENT | AT_IDENT